---
title: "(WIP)[책읽기] 마이크로서비스 아키텍쳐 구축"
---

![](/public/img/2022-01-26-Enterprise-Intergration-Patterns_1.jpg)
* 초판: 2017년 3월 (원판: 2015년 2월)
* 한빛미디어
 
　직군을 막론하고 최근 Cloud-Native Application(CNA) 관련역량이 필수불가결해졌다. 특히 MSA가 과연 우리 조직구조와 비즈니스에 적합한 구조일까라는 궁금증도 있었고, 내 머리 속에 산재되어있는 개념들을 출판된 책 서술되는 형태를 빌려 쭉 정리하면 좋겠다는 생각에 독서와 함께 포스팅해봤다. 이 책의 원판 출판일은 무려 7년전인 2015년 2월으로, 벌써 트랜드가 두세번은 바뀌었을 시간인 책이다. 제법 오래된 책이지만, MSA가 각광을 받기시작할때 쓰여지던 책이라 전통 서비스 구조에 대한 문제점(특히 Monolithic)과 그에 대한 해결방법에 대한 서술이 충분했던 것 같다. 물론 원판출판 이후에 트랜디한 기술들이 많이나왔기에 이 점을 감안해야한다. 참고로 본 포스팅은 내 의식의 흐름과 강한주관을 따르기 때문에, 본문 내용이 책의 목차 순서에 맞추어 정렬되어있지않다.

<hr/>
# 개요<br/>
　이 책은 기존 통합계에서 설계해왔던 Monolithic 앱 설계기법에 대한 문제점을 나열하고, 그에 따른 MSA 필요성을 설명하며 설계 및 구축기법을 설명하고있다. 수년전, Monolithic 앱의 대항마로 분산 시스템 특히 SOA (서비스지향 아키텍쳐, Service-Oriented Architecture)는 떠오르는 키워드였다. 저자는 SOA는 훌륭한 아이디어였지만, 산업계 다수가 문제를 전체적으로 보지못하고 SOA를 잘하는 방법에 대한 합의는 부족했다며 이러한 SOA가 실패했었던 이유를 경계하고, MSA는  SOA에 대한 특정 접근법으로 봐야한다고 얘기한다. 그 때문인지 최근 SOA라는 용어는 거의 쓰이지 않는다. 그래도 책에 자주 언급되는 생소한 내용이니 SOA에 대한 특징을 간략히 정리해보고 가자.

**SOA의 특징**
*  기존 Monolithic 앱에서  의미있는 서비스(기능)단위를 공통 서비스로 묶어 재사용성을 장려하는 아키텍쳐
*  서비스(모듈)간의 의존성을 최대한 줄임으로서, 느슨한 결합을 유지
*  Biz service / Common biz service / insfrastructure service 등 서비스 별 계층 구조를 가지고있음
*  서비스 수준의 재사용성을 추구한다는 점에서, MSA와 추구하는 가치/철학은 다르지 않음

　아래는 책에 묘사되어있는 내용은 아니다. 간략하게 Monolithic, SOA, MSA 각 패턴별 설계 주요특징을 도식화해봤다. 
![](/public/img/2022-01-26-Enterprise-Intergration-Patterns_0.PNG)

　확실히 최근 MSA를 소개하는 내용들과 SOA의 주된내용이 크게 다르지않다. 그 때문인지 이 책에서는  SOA에서 MSA로 마이그레이션하는 예를 들기보다는 Monolithic에서 MSA로 마이그레이션하는 예시를 들며 설계기법을 설명해 나가고있다. 

**은탄환은 없다. 아키텍트의 역할**<br/>
　어떤 설계패턴이든 '은탄환'이 되는 설계는 없다.  각각을 재단하듯이 설명하려고 하지않는게 당연하다고 생각한다. 저자도 이를 중요시하며, 아키텍트의 역할에 대해 견고히 제시하고, 아키텍트는 '진화적 아키텍트'가 되어야한다고 강조한다.

* 비전: 명료하게 소통되고, 시스템이 고객과 조직의 요구 사항을 충족하도록 돕는 기술 비전이 있는지 확인하라.
* 공감: 고객과 동료에 대한 여러분 결정의 파급력을 이해하라
* 협업: 비전을 정의하고, 다듬고, 실행하기 위해 가능한 한 많은 동료와 협업하라.
* 적응성: 기술 비전이 고객과 조직이 요구하는 것을 반영하는지 확인하라.
* 자율성: 여러분 팀의 표준화와 자율성 사이에서 올바른 균형을 찾아내라.
* 거버넌스: 시스템이 기술 비전에 맞게 구현되고 있는지 확인하라.

> 아키텍트는 많은 것에 대해 책임을 진다. 그들은 개발을 이끌 수 잇는 일련의 원칙을 정하고, **원칙들이 조직의 전략과 일치하도록 보장할 뿐만 아니라** 이 원칙들로 인해 개발자를 비참하게 만드는 실천 사항이 만들어지지 않도록 해야한다. 최신 기술을 유지하고, **올바른 트레이드오프를 결정**해야한다. 이는 실로 엄청난 책임이다. 그뿐 아니라 아키텍트는 사람들과 함께 나아가야한다.<br/>
> ...<br/>
> (중략) <br/>
> ...<br/>
>  거대한 모놀리식 시스템에서는 사람들이 성장하고 무엇인가를 소유할 기회가 거의 없다. 반면 MSA에서 우리는 독립적 수명주기를 가진 수많은 자율적인 코드베이스를 지닌다. 사람들이 더 많은 책무를 맡기 전에 **개별 서비스의 소유권을 부여함으로써 그들을 성장시키는 것은 그들 자신의 경력 목표를 성취하도록 돕는** 훌륭한 방법일 뿐만 아니라 다른 담당자들의 짐도 덜어준다.

　아키텍트가 아닐지라도, 시스템 구성원으로서도 고민해볼만한 문제다. 특히  저자는 조직구성과 아키텍트에 대한 상관관계에 대한 서술을 많이하는데 바로 콘웨이의 법칙(Conyway's Law)이다.

<hr/>
# 콘웨이 법칙(Conway's Law)<br/>
>**그 어떤 조직도 시스템(정보시스텀만이 아닌 좀 더 포괄전인 의미의 시스템)을 설계할 때 필연적으로 그 조직의 커뮤니케이션 구조를 모방하여 만든다.** <br/>
> Any organization that designs a system (defined more broadly here than just information systems) will inevitably produce a design whose structure is a copy of the organization's communication structure.

　맬빈 콘웨이의 논문 [「위원회가 고안하는 방식(Melvin Conwa, "How Do Commitees Invent", 1984)」](http://www.melconway.com/Home/Committees_Paper.html){:target="blank"} 의 주제이다. 저자는 이 법칙에 대한 재현을 아주 다양한 상황에서 목격했기에 이 법칙이 옳다고 믿는다고 한다.  콘웨이의 법칙은 실제로도 많이 인용되었으며 많은 후속연구가 진행되었다. 물론 입증되지는 않았지만, 경험과 사례들로 미루어 봤을때 조직구조가 시스템과 시스템의 본질에 큰 영향을 준다는 것을 보여준다.

**넷플릭스와 아마존**<br/>
　최근 업계에 있었다면 한번은 들어봤을법한 사례다. '팀의 규모가 피자 두판으로 식사를 마칠 수 없는 규모가 돼서는 안된다'는 아마존의 **피자 두 판 크기의 팀** 법칙은 유명하다.
> 담당 서비스의 전체 수명주기를 소유하는 작은팀의 추구는 아마존이 AWS를 만들 수 있었던 일등 공신이다. 그리고 아마존은 각 팀이 자립하는 데 필요한 도구들을 만들어야 했다.<br/>
> 넷플릭스는 아마존의 사례를 교훈삼아 처음부터 작고 독립적인 팀을 조직했고 그 결과 독립적인 서비스를 만들 수 있었다. 이를 통해 변경 속도에 최적화된 시스템 아키텍처를 확보할 수 있었다.

<br/>

**고려요소들**<br/>
* 의사소통 비용: 지리적으로 분산된 팀의 의사소통 비용이 높을수록 변경을 조율하는 비용 또한 높아짐.
* 서비스 소유권: 앱의 배포와 유지보수까지 한 팀이 책임지게 하면 그 보상으로 배포하기 쉬운 서비스가 만들어짐.
* 공유 서비스는 차선책: 공유서비스는 차선책 모델이지만, 왜 공유서비스 구조를 가지는 이해하고 있어야함. 만약 공유서비스를 없앨 수 없다면 내부 오픈 소스로 관리. 단, 오픈소스 관리정책을 차용하여 관리할 것(신뢰/비신뢰 커미터, 관리자 등...).
* 경계가 있는 컨텍스트

> 콘웨이의 법칙은 시스템을 조직 구조와 다르게 설계할 때의 위험을 강조한다. 이 법칙은 서비스의 소유권을 동일 위치의 팀과 나란히 정렬시킬 수 있도록 해준다. 그리고 그 팀은 스스로 조직의 경계와 동일한 경계가 있는 콘텍스트 주위로 정렬된다. 이 둘이 나란히 배치되지 않는다면 이 장에서 설명한 많은 불안 요소가 발생 할 것이다. 우리는 서비스 소유권과 조직 간의 관계를 이해함으로써 구축할 시스템과 조직이 부합되도록 해야 할 것이다.

<hr/>

# 모델링 (Modeling) <br/>
　저자는 모델링에 있어, 다음 두 가지 개념을 강조하는데, 이는 흡사 객체지향프로그래밍의 SOLID 원칙과 닮았다. 클래스(객체)를 잘 나눠야 하듯이, 서비스를 나누는 '경계'를 잘 나눠야함을 강조한다.
- 느슨한 결합: 서비스가 느슨히 결합되어있으면 하나의 서비스가 변경될 때 다른 서비스가 변경되는 일이 없다.
- 강한 응집력: 서로 연관된 행위가 한 곳에 모이고, 다른 경계와는 가능한 한 느슨하게 소통할 수 있도록 한다.

　다시 강조하지만, 위 두 개념은 결국 '경계'를 잘 나누는데에서 시작한다. '경계'를 나눈다는 것은 **서비스 도메인을 잘 이해하고있다는 바탕**에서 이루워져야한다는 것을 얘기한다. 그 개념을 설명하는 것이 '**경계가있는 컨텍스트(Bounded Context)**' 이다. 
 
 　**경계가 있는 컨텍스트(Bounded Context)** 는 도메인 주도 설계(Domain-Driven Desgin)에서 나온 개념으로서, 특정 모델에 대해 경계가 정해진 적용 가능성을 얘기한다. [명료한 경계에 의해 강제된 구체적인 책임, 2012](http://goo.gl/KRIcUx){:target="_blank"}

> 서비스 경계를 잘못 정하면 큰 비용이 들게 되므로 새로운 도메인 영역에 익숙해져서 안정화될 때까지 기다리는 것이 현명하다. <br/>
>  ... <br/>  (중략)  <br/> ... <br/>
>  결국 서비스 경계에 대한 초기 견해가 옳지 않았음이 명백해졌다. 이것은 서비스 간의 수많은 변경과 그에 따른 높은 비용 소모를 초래했고 결국 팀은 서비스를 다시 단기간에 경계를 구분 할 수 있는 단일 모놀리식 시스템으로 합쳤다. 그로부터 1년 뒤, 해당 모놀리식 시스템을 훨씬 안정적인 경계를 가진 마이크로서비스로 분리할 수 있었다.<br/>
>  ... <br/>  (중략)  <br/> ... <br/>
>  여러모로 기존 코드베이스를 마이크로서비스로 분해하는 것이 처음부터 마이크로서비스로 가는 것 보다 훨씬 쉽다.

　잘못된 경계로인한 성급한 분해를 경계해야한다. MSA를 소개 및 언급하는 여타 많은 포스팅에서도 '**처음부터 MSA로 짜지말고 Monolithic으로 설계한 뒤 서비스 규모가 커지면 MSA로 설계하라**'고 언급했었던 것을 본 것 같다. 이 책에서도 같은 의견을 게재하며, Monolithic 앱에서 MSA로 전환하는 방법을 소개하는 내용을 위주로 책 내용을 풀어나가고있다. 이렇게 하는 모든 이유는 **도메인에 대한 이해가 선행**되어야하기 때문이며 그에 따른 경계 설정이 중요하다. 이렇게 경계가 설정된 콘텍스트들은 접합부를 찾는 데 중요한 도구고, MSA를 이 경계에 정렬하여 우리의 최종 시스템이 온전한 장점들을 유지하도록 만들어야 한다.
 
　(사족1) 여기서 문득 생각이 드는게, 책의 저자가 SI업계에 오래 몸 담았었고 그래서 더더욱이 도메인을 강조하는게 아닐까라는 생각이 든다. (번역해주신분께서도 책을 쓰실때만해도 업계에 계셨던걸로 아는데 지금은 떠나신것 같다..?) 난 SI 업계에 몸을 담고있다. 도메인이 중요하다는 얘기는 리더급 선배들에게 숱하게 들어봤었다. '단순히 로직잘짜는건 중요도가 높지않다. 도메인 이해도가 훨씬 중요하다'고 얘기해줬었던 분들이 적지않았었다. 신입이었을 당시에는 '업의 특이성도 있고, 무엇보다 고객니즈를 파악하는게 너무나도 중요하니까' 정도로 이해했었지만, 지금 생각해보면 '도메인을 잘 알고, 기획을 잘해야(BC를 잘 나눠야) 프로젝트 안망한다. 잘못 기획(모델링)하면 XX싼다'라는 뉘앙스로 얘기해주셨을 수도 있겠다는 생각이 든다.
 
 　(사족2) 최근 더 뼈저리게 느끼는데, IT업이 아닌 전문분야(금융업, 제조업 등...)의 서비스를 만든다는 건 어려운 일이다. 개발자가 어떻게 그걸 다 알겠어. 개발자가 다 알아서 만들 수 있을 깊이의 도메인이라면 개발자가 회사를 차려버리지 뭐하러 고객한테 XXX 깨지면서 만들어주겠나. 디지털 트랜스포메이션이라고 잘 포장하는데, 요샌 또 이 키워드를 필두로 IT에 대한 중요성이 제고되고있어서 각 도메인 업체에서도 관련인력 확보하는데에 애를 쓰고있는 듯하다. 오촉을 곤두세우고 이 격변의 시기를 맞이해야한다.

<hr/>
# 통합 (Integration)<br/>
　MSA 통합에 있어 궁극적으로 추구하는 것이 무엇이며, 이상적인 통합이 어떤 것일지 생각해봐야한다. (말그대로 이상적인 내용이다. 간단하게 정리하고 넘어간다)

* **호환성을 깨뜨리는 변경 피하기**
* **기술 중립적인 API**
* **내부 구현 상세 감추기**
* **서비스 단순화**

　고민해야되는 부분들을 다음과 같이 서술하고있다.

* **공유DB통합 피하기**: 외내부 결합되는 것을 허용하기에 테스트가 쉽지 않다. / 강한 응집력과 느슨한 결합력을 잃는다. <br/>
* **동기/비동기**<br/>
 	동기: 작업이 언제 완료되었는지 알기쉽기때문에 추론이 쉽지만,  원격서버에 대한 호출이 완료될 때까지 연산 작업이 중단됨.<br/>
	비동기: 호출자는 작업이 완료되었다는 회신을 기다리지않는다. 때문에 중단된 호출이 성능 저하를 일으키는 곳에서 짧은 지연시간이 필요할때 적합하다.<br/>
	비동기 이벤트 기반: 결합도가 매우 낮은 방식으로서, 이벤트를 발산하는 클라이언트가 이벤트에 반응하는 대상을 알지 못한채로 이벤트를 발산한다.
* **오케스트레이션 / 코레오그래피**: 오케스트레이션 보단 코레오그래피<br/>
 	오케스트레이션(orchestration): 중앙에 의존하는 방식 / 고객 서비스에 지나치게 많은 중앙관리 권한이 부여됨 / 높은 변경 비용을 수반함.<br/>
 	코레오그래피(choreography): 시스템의 각 부분에 작업 내용을 알리고 세부 사항을 수행하게 하는 방식 / 이벤트만을 발산함으로써 느슨한 결합을 이끌어 냄. / 단, 모니터링을 할 수 있는 환경을 추가하는 작업이 필요함.<br/>
* **RPC or REST? 통신방식에 대한 고민** <br/>
 낮은 레이턴시가 필요한 서비스가 아니고선 웬만한건 REST로 설계한다는 뉘앙스로 서술하고있다. 다만 gRPC의 릴리즈가 2016.08이니, 릴리즈 이전에 퍼블리싱된 이 책의 원판에서는 gRPC 언급은 없다. 우선 이 포스트에서는 책이 언급하는 내용을 정리하고, 후속 포스트에서 gRPC에 대한 내용을 정리하며 공부해봐야겠다.
1. 원격 프로시저 호출(Remote Procedure Call)<br/>
	쓰기쉬움 / 하지만 클라-서버간 기술결합을 초래해 사용될 기술을 제한하기도함 / 개발자가 인지를 못하고 서비스 경계를 넘어서 호출 할 수 도 있음 / 네트워크의 나쁜 신뢰성을 고려하여 회복력에 대한 고찰이 필요함 / 그럼에도 불구하고 RPC가 형편없다고 단정 짓기는 어려움.<br/>
	그래도 써야한다면: 네트워크가 완전히 은폐될 정도로 원격 호출을 추상화하지 말것 / 서버와 보조를 맞춘 클라이언트의 업그레이드 없이도 서버 인터페이스를 발전시킬 수 있는지 확인 할 것.
2.  REST <br/>
 JSON, XML ... etc 많이들 사용 / 가끔은 RPC가 나은 경우가 있음 (낮은 지연시간이 필요한 통신) / 인기 많아서 괜찮은 프레임워크가 많음 / 물론 지나친 편의를 주의하며 사용할것(사용자에게 보여주지말아야할 DB내용을 고대로 deerialize해서 외부로 노출 시킨다던지..)
* **비동기 이벤트 기반의 협업 구현** <br/>
	EDM(Event Driven Microservice)이나 Event Bus를 언급하지는 않지만, 비슷한 내용이 언급되는 듯 하다. 사실 EDM 혹은 EDA 등등 역시 2015년에 들어서야 떠오르던 키워드라, 책에는 관련된 개념을 언급하는 내용이 없지않을까 싶다. EDM 관련된 내용은 역시 후속 포스트로 정리하며 공부해야겠다. 책에서는 다음 두 가지 내용을 소개하고있다. 
1. 	미들웨어에 메세지 중개자를 추가하여 처리하는 방법<br/>
RabbitMQ를 활용하여 구성하는 방법을 소개했다. 최근에는 아파치 Kafka 역시 많이 사용한다.
2. 	HTTP 기반 프로토콜인 ATOM을 활용하여 이벤트 기반 설계하는 방법<br/>
ATOM은 Atom Syndication Format과 Atom Publishcation Protocol을 지칭한다. RSS(Real Simple Syndication)와 함께 언급되는 것 같은데, Rich Site Summary로 잘 알려진 그것이다. RSS 포멧의 단점을 극복하기위하여 설계되었다고한다.

* 반응형 확장 Rx
* DRY(Don't Reat Yourself)와 공유코드 사용(재사용)의 위험성
	* 공유코드
	* 클라이언트 라이브러리
* Sementic Versioning 유의적 버전관리
* 관대한 독자 (Tolerant Reader) 패턴
* 포스텔의 법칙 혹은 견고성의 법칙
* 확장-수축패턴

<hr/>

# 사용자 인터페이스 (User Interface)
UI 는 중요하니까..

<hr/>
# 후속포스트
* MSA와 gRPC
* Event Driven Microservice
* 블로킹과 논블로킹
